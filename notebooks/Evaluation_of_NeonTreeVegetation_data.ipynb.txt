{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "E6UymUAzr8OW"
      },
      "outputs": [],
      "source": [
        "#@title Installing libraries for Evaluation of Neon data\n",
        "! pip install --upgrade deepforest albumentations pyyaml\n",
        "#pip install git+https://github.com/weecology/DeepForest.git\n",
        "!pip uninstall opencv-python-headless -y\n",
        "!pip install opencv-python-headless==4.1.2.30\n",
        "!pip install GDAL\n",
        "!pip install matplotlib\n",
        "!pip uninstall pytorch_lightning -y\n",
        "!pip install pytorch_lightning"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 7,
      "metadata": {
        "id": "aNx182d16137"
      },
      "outputs": [],
      "source": [
        "#@title Importing the required libraries\n",
        "from osgeo import gdal\n",
        "import os\n",
        "import numpy as np\n",
        "from deepforest import main\n",
        "from deepforest import get_data\n",
        "from deepforest import utilities\n",
        "from deepforest import preprocess\n",
        "import matplotlib.pyplot as plt\n",
        "from torch import optim, nn, utils, Tensor\n",
        "from torchvision.datasets import MNIST\n",
        "from torchvision.transforms import ToTensor\n",
        "import pytorch_lightning as pl\n",
        "import tensorflow as tf\n",
        "import glob"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 36
        },
        "id": "cr0sjU9OLznK",
        "outputId": "c31488be-6156-4a02-b868-05afb5b3fd52"
      },
      "outputs": [
        {
          "data": {
            "application/vnd.google.colaboratory.intrinsic+json": {
              "type": "string"
            },
            "text/plain": [
              "'/device:GPU:0'"
            ]
          },
          "execution_count": 3,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "#@title Checking for GPU\n",
        "device_name=tf.test.gpu_device_name()\n",
        "device_name"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "ocqEjI480EAr"
      },
      "outputs": [],
      "source": [
        "#@title Fetching NeonTreeEvaluation data\n",
        "# Fetching data from NeonTreeEvaluation\n",
        "!git clone https://github.com/weecology/NeonTreeEvaluation.git\n",
        "!mkdir data"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "baVrl0P5sKSe"
      },
      "outputs": [],
      "source": [
        "#@title For evaluation of rasters and plotting results\n",
        "class Scores:\n",
        "\n",
        "  model = main.deepforest()\n",
        "  model.use_release()\n",
        "\n",
        "  num_images=1000\n",
        "\n",
        "  arrX={}\n",
        "  arrY={}\n",
        "\n",
        "  for i in range(num_images):\n",
        "    arrX[i+1]=[]\n",
        "    arrY[i+1]=[]\n",
        "\n",
        "  def resample_image_in_place(self, image_path, new_res, resample_image):\n",
        "      args = gdal.WarpOptions(\n",
        "          xRes=new_res,\n",
        "          yRes=new_res\n",
        "      )\n",
        "      gdal.Warp(resample_image, image_path, options=args)\n",
        "\n",
        "  def evaluation_image(self, image_path, resolutionxyz, counter):\n",
        "\n",
        "      # Resampling Image with \n",
        "      self.resample_image_in_place(image_path, resolutionxyz, f'/content/data/temp_image_{resolutionxyz}_resolution.tif') \n",
        "\n",
        "      # any_resolution resoluton prediction\n",
        "      image_path_resolutionxyz_resolution = f'/content/data/temp_image_{resolutionxyz}_resolution.tif'\n",
        "      boxes = self.model.predict_image(path=image_path_resolutionxyz_resolution, return_plot=False)\n",
        "      df = boxes.head()\n",
        "      df['image_path'] = image_path_resolutionxyz_resolution\n",
        "      df.to_csv(f'/content/data/file_{resolutionxyz}_resolution.csv')\n",
        "\n",
        "      # Evaluation of any_resolution\n",
        "      csv_file = f'/content/data/file_{resolutionxyz}_resolution.csv'\n",
        "      root_dir = os.path.dirname(csv_file)\n",
        "      results = self.model.evaluate(csv_file, root_dir, iou_threshold=0.4, savedir=None)\n",
        "      print(str(results[\"box_recall\"]) + f\" is evaluation of projected data at {resolutionxyz}\")\n",
        "      self.arrX[counter].append(resolutionxyz)\n",
        "      self.arrY[counter].append(results[\"box_recall\"])\n",
        "\n",
        "  def plotting(self):\n",
        "    plt.figure()\n",
        "\n",
        "    for i in range(self.num_images):\n",
        "      plt.scatter(self.arrX[i+1],self.arrY[i+1], marker='o')\n",
        "\n",
        "    plt.xlabel(\"Resolution\")\n",
        "    plt.ylabel(\"Evaluation\")\n",
        "    plt.show()\n",
        "\n",
        "  def results(self, input_image_path, counter, resolution_values):\n",
        "\n",
        "    # Normal resolution prediction\n",
        "    image_path = input_image_path\n",
        "    boxes = self.model.predict_image(path=image_path, return_plot=False)\n",
        "    df = boxes.head()\n",
        "    df['image_path'] = image_path\n",
        "    df.to_csv('/content/data/file_normal.csv')\n",
        "\n",
        "    # Evaluation of normal\n",
        "    csv_file = '/content/data/file_normal.csv'\n",
        "    root_dir = os.path.dirname(csv_file)\n",
        "    results = self.model.evaluate(csv_file, root_dir, iou_threshold=0.4, savedir=None)\n",
        "    print(str(results[\"box_recall\"]) + \" is evaluation of normal data\")\n",
        "\n",
        "    self.arrX[counter].append(0)\n",
        "    self.arrY[counter].append(results[\"box_recall\"])\n",
        "\n",
        "    # Evaluation for user defined values\n",
        "    for i in resolution_values:\n",
        "      self.evaluation_image(image_path, i, counter)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 8,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "13PRor8lPr7I",
        "outputId": "e0744977-4a11-4d9c-8f2b-24f79752e0ea"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "2291\n"
          ]
        }
      ],
      "source": [
        "#@title Counting number of Images in our dataset\n",
        "countimages=0\n",
        "for file in glob.iglob(f\"/content/NeonTreeEvaluation/evaluation/RGB/*\"):\n",
        "  countimages+=1\n",
        "\n",
        "print(countimages)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "367blP8Z3JSp"
      },
      "outputs": [],
      "source": [
        "#@title Calculating evaluation scores on different resolutions for rasters\n",
        "scores = Scores()\n",
        "\n",
        "counter=1\n",
        "for file in glob.iglob(f\"/content/NeonTreeEvaluation/evaluation/RGB/*\"):\n",
        "  if counter<=scores.num_images:\n",
        "    print(counter)\n",
        "    print(f\"Filename: {file}\")\n",
        "    try:\n",
        "      scores.results(file, counter, resolution_values=[0.20, 0.40, 0.60, 0.80, 1, 1.20, 1.40, 1.60, 1.80, 2, 2.5])\n",
        "    except:\n",
        "      print(f\"File has some invalid data, Filename : {file}\")\n",
        "  \n",
        "  counter+=1\n",
        "\n",
        "scores.plotting()\n",
        "plt.close()"
      ]
    }
  ],
  "metadata": {
    "accelerator": "GPU",
    "colab": {
      "provenance": []
    },
    "gpuClass": "standard",
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
